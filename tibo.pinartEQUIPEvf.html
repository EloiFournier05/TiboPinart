<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Tibo Pinart ‚Äì V1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #0d0d0d;
      --bg-card: #1f1f1f;
      --bg-card-soft: #151515;
      --border: #2b2b2b;
      --text: #ffffff;
      --text-muted: #9e9e9e;
      --yellow: #ffd600;
      --green: #00a85a;
      --red: #d7263d;
      --white-maillot: #f6f6f6;
      --accent: #ffb100;
      --danger: #ff4337;
      --radius: 12px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: var(--bg);
      color: var(--text);
      padding: 8px;
    }

    .app {
      max-width: 480px;
      margin: 0 auto;
    }

    /* HEADER */

    .header {
      background: var(--bg-card);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      padding: 10px 14px;
      margin-bottom: 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .header-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .timer-label {
      font-size: 0.75rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .timer-value {
      font-variant-numeric: tabular-nums;
      font-size: 1.4rem;
      font-weight: 700;
    }

    .settings-btn {
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 1.4rem;
      padding: 4px;
      cursor: pointer;
    }

    .next-event {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-top: 2px;
    }

    /* JOUEURS */

    .players-card {
      background: var(--bg-card);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      padding: 6px 0;
      margin-bottom: 10px;
    }

    .player-row {
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .player-row:last-child {
      border-bottom: none;
    }

    .player-top-line {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .player-rank {
      font-size: 0.9rem;
      color: var(--text-muted);
      margin-right: 6px;
      min-width: 1.5rem;
    }

    .player-name {
      font-weight: 600;
      font-size: 1rem;
    }

    .player-incidents {
      font-size: 0.9rem;
      color: var(--danger);
      margin-left: 4px;
    }

    .player-maillots {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.8rem;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      padding: 2px 6px;
      border-radius: 999px;
      font-variant-numeric: tabular-nums;
      font-size: 0.75rem;
      border: 1px solid var(--border);
      background: var(--bg-card-soft);
    }

    .badge-yellow-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--yellow);
    }

    .badge-green-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--green);
    }

    .badge-red-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--red);
    }

    .badge-white-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--white-maillot);
    }

    .player-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 2px;
    }

    .btn-fini {
      font-size: 0.8rem;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--yellow);
      background: rgba(255, 214, 0, 0.08);
      color: var(--yellow);
      cursor: pointer;
    }

    .btn-fini:disabled {
      opacity: 0.5;
      cursor: default;
    }

    /* ZONE √âV√âNEMENT */

    .event-zone {
      min-height: 60px;
      border-radius: var(--radius);
      border: 1px dashed var(--border);
      padding: 8px 10px;
      background: #101010;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .event-title {
      font-weight: 600;
      margin-bottom: 4px;
      color: var(--text);
    }

    .event-body {
      line-height: 1.3;
      white-space: pre-wrap;
    }

    /* SETUP MODAL */

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    .modal {
      background: var(--bg-card);
      border-radius: 16px;
      border: 1px solid var(--border);
      padding: 16px 14px 18px;
      width: 100%;
      max-width: 420px;
      max-height: 90vh;
      overflow-y: auto;
      box-sizing: border-box;
    }

    .modal h1 {
      font-size: 1.3rem;
      margin-bottom: 4px;
    }

    .modal p {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-bottom: 12px;
    }

    .form-group {
      margin-bottom: 12px;
    }

    .form-label {
      display: block;
      font-size: 0.8rem;
      margin-bottom: 4px;
      color: var(--text-muted);
    }

    .form-input, .form-select, .form-textarea {
      width: 100%;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--bg-card-soft);
      color: var(--text);
      padding: 6px 8px;
      font-size: 0.9rem;
    }

    .form-textarea {
      min-height: 100px;
      resize: vertical;
    }

    .btn-primary {
      width: 100%;
      border-radius: 999px;
      padding: 8px 12px;
      border: none;
      background: linear-gradient(135deg, var(--yellow), var(--accent));
      color: #000;
      font-weight: 700;
      font-size: 0.95rem;
      cursor: pointer;
      margin-top: 4px;
    }

    .btn-secondary {
      width: 100%;
      border-radius: 999px;
      padding: 8px 12px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text-muted);
      font-size: 0.85rem;
      cursor: pointer;
      margin-top: 6px;
    }

    .error-text {
      color: var(--danger);
      font-size: 0.8rem;
      margin-top: 4px;
      white-space: pre-wrap;
    }

    #main-content {
      display: none;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--bg-card-soft);
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    @media (max-width: 360px) {
      .player-maillots {
        flex-wrap: wrap;
      }
    }

    @media (max-width: 600px) {
      #cover-screen {
        height: 100vh !important;
        overflow: hidden !important;
        background-size: contain !important;
        background-position: top center !important;
        background-repeat: no-repeat !important;
        background-color: #000;
      }
    }
  </style>
</head>
<body>
  <!-- √âCRAN DE COUVERTURE -->
  <div id="cover-screen" style="
    position:fixed;
    top:0; left:0; width:100%; height:100%;
    background: url('https://i.imgur.com/eva8EXh.png') center/cover no-repeat;
    background-color: rgba(0,0,0,0.25);
    background-blend-mode: darken;
    display:flex;
    flex-direction:column;
    justify-content:center;
    align-items:center;
    z-index:2000;
    color:white;
    text-align:center;
    padding:20px;
    transition: opacity 0.4s ease;
  ">
    <h1 style="
      font-size:3rem;
      margin-bottom:10px;
      letter-spacing:2px;
      font-weight:900;
      text-shadow:0 0 10px #000;
    ">TIBO PINART</h1>

    <h2 style="
      font-size:1.4rem;
      margin-bottom:40px;
      opacity:0.95;
      font-weight:600;
      text-shadow:0 0 10px #000;
    ">Le Tour du Bar</h2>

    <button id="btn-cover-start" class="btn-primary" style="
      font-size:1.4rem;
      padding:14px 24px;
      border-radius:12px;
      background:#ffd60a;
      color:#000;
      border:none;
      font-weight:700;
      box-shadow:0 0 12px rgba(0,0,0,0.5);
    ">Entrer</button>
  </div>

  <div id="main-content">
    <div class="app">
      <header class="header">
        <div class="header-top">
          <div>
            <div class="timer-label">Temps restant</div>
            <div class="timer-value" id="timer">--:--:--</div>
            <div id="next-event" class="next-event">Prochain √©v√©nement : chargement‚Ä¶</div>
            <div id="room-status" class="next-event">Room : hors-ligne</div>
          </div>
          <button class="settings-btn" id="btn-settings" title="Classements">‚öô</button>
        </div>
      </header>

      <section class="players-card" id="players-card"></section>

      <section class="players-card" id="teams-card" style="display:none; margin-top:8px;"></section>

      <div id="host-controls" style="text-align:center; margin-bottom:10px;">
        <button id="btn-sprint" class="btn-primary" style="width:auto; padding:8px 20px; font-size:1rem;">‚ö° SPRiNT !</button>
        <button id="btn-cote" class="btn-primary" style="width:auto; padding:8px 20px; font-size:1rem; background:#7E57C2; margin-left:6px;">‚õ∞Ô∏è C√¥te</button>
        <button id="btn-echappee" class="btn-primary" style="width:auto; padding:8px 20px; font-size:1rem; background:#F5F5F5; color:#000; margin-left:6px;">üö¥ √âchapp√©e</button>
        <button id="btn-incident" class="btn-primary" style="width:auto; padding:8px 20px; font-size:1rem; background:#d7263d; margin-left:6px;">‚ö†Ô∏è Incident</button>
      </div>

      <!-- Bouton Player -->
      <div id="player-controls" style="display:none; text-align:center; margin-bottom:10px;">
        <button id="btn-player-fini" class="btn-primary" style="width:100%; padding:12px 16px; font-size:1.05rem;">
          J‚Äôai fini ma pinte
        </button>
        <div id="player-hint" class="next-event" style="margin-top:6px;">
          Connect√© en Player
        </div>
      </div>

      <section class="event-zone" id="event-zone">
        <div class="event-title">Aucun √©v√©nement en cours</div>
        <div class="event-body">
          Quand une pinte est termin√©e, appuie sur ¬´ Fini ¬ª pour enregistrer le temps et mettre √† jour le Maillot Jaune.
        </div>
      </section>
    </div>

    <!-- MODAL SETUP INITIAL -->
    <div class="modal-backdrop" id="setup-modal">
      <div class="modal">
        <h1>Tibo Pinart</h1>
        <p>Jeu de bar inspir√© du Tour de France. Un t√©l√©phone au centre, des pintes, des maillots.</p>

        <!-- ROLE + ROOM -->
        <div class="form-group" style="border:1px solid var(--border); border-radius:12px; padding:10px;">
          <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:6px;">
            <div style="font-weight:700;">Connexion</div>
            <span class="pill" id="conn-pill">offline</span>
          </div>

          <div style="display:flex; gap:10px; font-size:0.9rem; margin-bottom:10px;">
            <label style="display:flex; align-items:center; gap:6px;">
              <input type="radio" name="role-mode" value="host" checked>
              Host
            </label>
            <label style="display:flex; align-items:center; gap:6px;">
              <input type="radio" name="role-mode" value="player">
              Player
            </label>
          </div>

          <label class="form-label" for="room-code">Room code</label>
          <input id="room-code" class="form-input" type="text" placeholder="ex: A7K3P" maxlength="10" style="text-transform:uppercase;">

          <div style="display:flex; gap:8px; margin-top:8px;">
            <button type="button" class="btn-secondary" id="btn-generate-room" style="width:50%;">G√©n√©rer</button>
            <button type="button" class="btn-secondary" id="btn-join-room" style="width:50%;">Rejoindre</button>
          </div>

          <div id="player-login-box" style="display:none; margin-top:10px;">
            <label class="form-label" for="player-name">Ton pr√©nom</label>
            <input id="player-name" class="form-input" type="text" placeholder="ex: Eloi">

            <div id="player-pick-box" style="display:none; margin-top:8px;">
              <label class="form-label" for="player-pick">S√©lection</label>
              <select id="player-pick" class="form-select"></select>
              <div class="next-event" style="margin-top:6px;">Si ton pr√©nom n‚Äôest pas trouv√©, s√©lectionne-le ici.</div>
            </div>
          </div>

          <details style="margin-top:10px;">
            <summary style="cursor:pointer; color:var(--text-muted); font-size:0.85rem;">Param√®tres Supabase</summary>
            <div style="margin-top:8px;">
              <label class="form-label" for="sb-url">SUPABASE_URL</label>
              <input id="sb-url" class="form-input" type="text" placeholder="https://xxxxx.supabase.co">
              <label class="form-label" for="sb-key" style="margin-top:8px;">SUPABASE_ANON_KEY</label>
              <textarea id="sb-key" class="form-textarea" style="min-height:70px;" placeholder="eyJhbGciOi..."></textarea>
              <button type="button" class="btn-secondary" id="btn-save-supabase" style="margin-top:8px;">Sauvegarder</button>
              <div class="next-event" style="margin-top:6px;">
                Stock√© en localStorage sur cet appareil.
              </div>
            </div>
          </details>

          <div class="error-text" id="conn-error" style="margin-top:8px;"></div>
        </div>

        <!-- HOST SETUP -->
        <div id="host-setup">
          <div class="form-group">
            <label class="form-label" for="tour-duration">Dur√©e du Tour</label>
            <select id="tour-duration" class="form-select">
              <option value="60">1h</option>
              <option value="120">2h</option>
              <option value="180" selected>3h</option>
              <option value="240">4h</option>
              <option value="300">5h</option>
            </select>

            <div style="margin-top:12px;">
              <span style="font-weight:600;">Profil de l'√©tape</span>
              <div style="margin-top:4px; font-size:0.9rem;">
                <label><input type="radio" name="profil-etape" value="Ville" checked> Ville (soft)</label><br>
                <label><input type="radio" name="profil-etape" value="Plaine"> Plaine (medium)</label><br>
                <label><input type="radio" name="profil-etape" value="Montagne"> Montagne (hard)</label>
              </div>
            </div>
          </div>

          <div class="form-group">
            <label class="form-label" for="players-input">Pr√©noms des joueurs (un par ligne)</label>
            <textarea id="players-input" class="form-textarea" placeholder="Louis&#10;Eloi&#10;Gabriel&#10;Lo√Øc"></textarea>
          </div>

          <!-- MODE √âQUIPES -->
          <div class="form-group" style="margin-top:8px; border-top:1px solid var(--border); padding-top:8px;">
            <label class="form-label">Mode √©quipes (optionnel)</label>

            <label style="font-size:0.85rem; display:flex; align-items:center; gap:6px; margin-bottom:6px;">
              <input type="checkbox" id="teams-enabled" />
              Activer les √©quipes
            </label>

            <div id="teams-setup" style="display:none; margin-top:6px;">

              <div style="display:flex; gap:8px; margin-bottom:8px;">
                <div style="flex:1; border:1px solid var(--border); border-radius:8px; padding:6px;">
                  <div style="font-size:0.8rem; margin-bottom:4px; font-weight:600;">√âquipe 1</div>
                  <input id="team1-name" class="form-input" type="text" value="√âquipe 1" style="margin-bottom:4px;">
                  <input id="team1-tag" class="form-input" type="text" value="EQ1" maxlength="3" style="margin-bottom:4px; text-transform:uppercase;">
                  <label style="font-size:0.75rem; color:var(--text-muted);">Couleur</label>
                  <input id="team1-color" type="color" value="#FFD600" style="width:100%; margin-top:2px;">
                </div>

                <div style="flex:1; border:1px solid var(--border); border-radius:8px; padding:6px;">
                  <div style="font-size:0.8rem; margin-bottom:4px; font-weight:600;">√âquipe 2</div>
                  <input id="team2-name" class="form-input" type="text" value="√âquipe 2" style="margin-bottom:4px;">
                  <input id="team2-tag" class="form-input" type="text" value="EQ2" maxlength="3" style="margin-bottom:4px; text-transform:uppercase;">
                  <label style="font-size:0.75rem; color:var(--text-muted);">Couleur</label>
                  <input id="team2-color" type="color" value="#00AEEF" style="width:100%; margin-top:2px;">
                </div>
              </div>

              <button type="button" class="btn-secondary" id="btn-refresh-teams">
                Mettre √† jour la liste des joueurs
              </button>

              <div id="teams-assignment" style="margin-top:8px; font-size:0.8rem;">
                <div style="color:var(--text-muted);">
                  Cliquez sur ¬´ Mettre √† jour la liste des joueurs ¬ª pour assigner chaque joueur √† une √©quipe.
                </div>
              </div>

            </div>
          </div>

          <button class="btn-primary" id="btn-start">Lancer le Tour</button>
          <div class="error-text" id="setup-error"></div>

          <button class="btn-secondary" id="btn-demo">Remplir un exemple</button>
        </div>

        <!-- PLAYER INFO -->
        <div id="player-setup" style="display:none;">
          <div class="next-event" style="margin-top:6px;">
            Player: rejoins une room existante, puis utilise ¬´ J‚Äôai fini ma pinte ¬ª.
          </div>
        </div>

        <div class="next-event" style="margin-top:10px;">
          Astuce: le Host doit lancer le Tour. Les Players se connectent ensuite au m√™me Room code.
        </div>
      </div>
    </div>

    <!-- MODAL CLASSEMENTS -->
    <div class="modal-backdrop" id="classement-modal" style="display:none;">
      <div class="modal">
        <h1>Classements</h1>
        <p>R√©sum√© des maillots et des points.</p>
        <div id="classement-content" style="max-height:60vh; overflow-y:auto; font-size:0.85rem;"></div>
        <button class="btn-secondary" id="btn-classement-close" style="margin-top:10px;">Fermer</button>
      </div>
    </div>

    <!-- SONS -->
    <audio id="snd-sprint"    src="snd/sprint.mp3"    preload="auto"></audio>
    <audio id="snd-cote"      src="snd/cote.mp3"      preload="auto"></audio>
    <audio id="snd-echappee"  src="snd/echappee.mp3"  preload="auto"></audio>
    <audio id="snd-incident"  src="snd/incident.mp3"  preload="auto"></audio>
  </div>

  <!-- Supabase CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <script>
    /*
      SUPABASE SCHEMA MINIMAL (√† ex√©cuter dans SQL Editor)

      create table if not exists public.rooms (
        id uuid primary key default gen_random_uuid(),
        code text unique not null,
        state jsonb not null default '{}'::jsonb,
        updated_at timestamptz not null default now()
      );

      -- Activer Realtime sur rooms
      -- Dans Supabase: Database -> Replication -> ajouter "rooms" (ou via UI Realtime)

      -- RLS (simple, pour usage priv√© en soir√©e)
      alter table public.rooms enable row level security;

      create policy "rooms_select_all" on public.rooms
        for select using (true);

      create policy "rooms_insert_all" on public.rooms
        for insert with check (true);

      create policy "rooms_update_all" on public.rooms
        for update using (true) with check (true);

      Attention: ces policies sont ouvertes. Pour un vrai produit, il faut restreindre.
    */

    // ==========================
    // √âTAT GLOBAL + √âV√âNEMENTS
    // ==========================

    // Sprint
    let sprintActif = false;
    let sprintCooldown = 0;
    let sprintLanceur = null;

    // C√¥te
    let coteActive = false;
    let coteCible = null;

    // √âchapp√©e
    let echappeeActive = false;
    let echappeeClics = [];

    // Incidents
    let incidentActif = false;
    let incidentData = null;

    const incidentsList = [
      { id: 1, type: "player", label: "Pas de main droite", duration: "1-pinte" },
      { id: 2, type: "player", label: "Pas de main gauche", duration: "1-pinte" },
      { id: 3, type: "player", label: "Boire debout", duration: "1-pinte" },
      { id: 4, type: "all", label: "Tout le monde change de place", duration: "instant" },
      { id: 5, type: "player", label: "Boire sans poser le verre", duration: "1-pinte" },
      { id: 6, type: "player", label: "Main sur la t√™te en buvant", duration: "1-pinte" },
      { id: 7, type: "player", label: "Doit annoncer '√Ä l‚Äôattaque !' avant chaque gorg√©e", duration: "1-pinte" },
      { id: 8, type: "all", label: "Tout le monde doit boire un verre d'eau", duration: "instant" },
      { id: 9, type: "player", label: "Interdiction de regarder le joueur choisi", duration: "5-min" },
      { id: 10, type: "player", label: "Accent impos√©", duration: "5-min" },
      { id: 11, type: "gameplay", label: "+5 secondes sur la prochaine pinte", duration: "1-pinte" },
      { id: 12, type: "gameplay", label: "Interdiction de lancer le prochain sprint", duration: "15-min" }
    ];

    const state = {
      joueurs: [],
      dureeMinutes: 180,
      tourFinTimestamp: null,
      tourStartTimestamp: null,
      timerInterval: null,

      pinteEnCours: true,
      finPinteOrdre: [],

      numeroPinte: 1,
      difficulte: "Plaine",

      timelineEvents: [],

      teams: []
    };

    // ==========================
    // SUPABASE + ROOM + ROLE
    // ==========================

    const LS_SB_URL = "tp_supabase_url";
    const LS_SB_KEY = "tp_supabase_key";
    const LS_ROOM_CODE = "tp_room_code";
    const LS_ROLE = "tp_role";
    const LS_PLAYER_NAME = "tp_player_name";

    let supa = null;

    let isHost = true;
    let roomId = null;
    let roomCode = null;
    let rtChannel = null;

    let applyingRemote = false;
    let pendingPlayerFinish = false;

    let selectedPlayerId = null;
    let selectedPlayerName = null;

    let pushDebounce = null;

    function nowSeconds() {
      return Date.now() / 1000;
    }

    function safeUpper(s) {
      return (s || "").toString().trim().toUpperCase();
    }

    function setRoomStatus(text) {
      const el = document.getElementById("room-status");
      if (el) el.textContent = text;
    }

    function setConnPill(text) {
      const el = document.getElementById("conn-pill");
      if (el) el.textContent = text;
    }

    function setConnError(text) {
      const el = document.getElementById("conn-error");
      if (el) el.textContent = text || "";
    }

    function readSupabaseConfigFromLS() {
      return {
        url: localStorage.getItem(LS_SB_URL) || "",
        key: localStorage.getItem(LS_SB_KEY) || ""
      };
    }

    function initSupabaseFromLS() {
      const cfg = readSupabaseConfigFromLS();
      if (!window.supabase) return false;
      if (!cfg.url || !cfg.key) return false;
      supa = window.supabase.createClient(cfg.url, cfg.key);
      return true;
    }

    function genCode(len = 5) {
      const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
      let out = "";
      for (let i = 0; i < len; i++) out += chars[Math.floor(Math.random() * chars.length)];
      return out;
    }

    function serializePayload() {
      return {
        v: 1,
        ts: nowSeconds(),
        state: {
          joueurs: state.joueurs,
          dureeMinutes: state.dureeMinutes,
          tourFinTimestamp: state.tourFinTimestamp,
          tourStartTimestamp: state.tourStartTimestamp,
          pinteEnCours: state.pinteEnCours,
          finPinteOrdre: state.finPinteOrdre,
          numeroPinte: state.numeroPinte,
          difficulte: state.difficulte,
          timelineEvents: state.timelineEvents,
          teams: state.teams
        },
        flags: {
          sprintActif, sprintCooldown, sprintLanceur,
          coteActive, coteCible,
          echappeeActive, echappeeClics,
          incidentActif, incidentData
        }
      };
    }

    function applyPayload(payload) {
      if (!payload || !payload.state || !payload.flags) return;

      applyingRemote = true;

      state.joueurs = payload.state.joueurs || [];
      state.dureeMinutes = payload.state.dureeMinutes ?? 180;
      state.tourFinTimestamp = payload.state.tourFinTimestamp ?? null;
      state.tourStartTimestamp = payload.state.tourStartTimestamp ?? null;
      state.pinteEnCours = payload.state.pinteEnCours ?? true;
      state.finPinteOrdre = payload.state.finPinteOrdre || [];
      state.numeroPinte = payload.state.numeroPinte ?? 1;
      state.difficulte = payload.state.difficulte || "Plaine";
      state.timelineEvents = payload.state.timelineEvents || [];
      state.teams = payload.state.teams || [];

      sprintActif = !!payload.flags.sprintActif;
      sprintCooldown = payload.flags.sprintCooldown || 0;
      sprintLanceur = payload.flags.sprintLanceur ?? null;

      coteActive = !!payload.flags.coteActive;
      coteCible = payload.flags.coteCible ?? null;

      echappeeActive = !!payload.flags.echappeeActive;
      echappeeClics = payload.flags.echappeeClics || [];

      incidentActif = !!payload.flags.incidentActif;
      incidentData = payload.flags.incidentData ?? null;

      applyingRemote = false;

      renderPlayers();
      updateNextEventLabel();
      tickTimerUIOnly();
      updateRoleUI();
      hydratePlayerSelectionFromState();
    }

    async function pushStateNow(reason) {
      if (!isHost) return;
      if (!supa || !roomId) return;
      if (applyingRemote) return;

      const payload = serializePayload();
      try {
        const { error } = await supa
          .from("rooms")
          .update({ state: payload, updated_at: new Date().toISOString() })
          .eq("id", roomId);

        if (error) {
          console.warn("Supabase update error:", error.message);
          if (reason) console.warn("Reason:", reason);
        }
      } catch (e) {
        console.warn("Supabase update exception:", e);
      }
    }

    function schedulePush(reason) {
      if (!isHost) return;
      if (!supa || !roomId) return;
      if (applyingRemote) return;

      if (pushDebounce) clearTimeout(pushDebounce);
      pushDebounce = setTimeout(() => pushStateNow(reason || "debounced"), 180);
    }

    async function createOrGetRoom(code) {
      if (!supa) throw new Error("Supabase non initialis√©");
      const upper = safeUpper(code);
      if (!upper) throw new Error("Room code vide");

      // 1) check exist
      const { data: existing, error: selErr } = await supa
        .from("rooms")
        .select("id, code, state")
        .eq("code", upper)
        .limit(1);

      if (selErr) throw new Error(selErr.message);

      if (existing && existing.length > 0) {
        return existing[0];
      }

      // 2) create
      const initPayload = serializePayload();
      const { data: created, error: insErr } = await supa
        .from("rooms")
        .insert([{ code: upper, state: initPayload }])
        .select("id, code, state")
        .single();

      if (insErr) throw new Error(insErr.message);
      return created;
    }

    async function joinRoom(code) {
      if (!supa) throw new Error("Supabase non initialis√©");
      const upper = safeUpper(code);
      if (!upper) throw new Error("Room code vide");

      const { data: rows, error } = await supa
        .from("rooms")
        .select("id, code, state")
        .eq("code", upper)
        .limit(1);

      if (error) throw new Error(error.message);
      if (!rows || rows.length === 0) throw new Error("Room introuvable");

      return rows[0];
    }

    function unsubscribeRealtime() {
      try {
        if (rtChannel) {
          rtChannel.unsubscribe();
          rtChannel = null;
        }
      } catch (e) {
        // ignore
      }
    }

    function subscribeRealtime(roomIdToSub, codeToSub) {
      if (!supa) return;

      unsubscribeRealtime();

      rtChannel = supa.channel("tp-room:" + codeToSub, {
        config: { broadcast: { self: true } }
      });

      // Receive actions (Player -> Host)
      rtChannel.on("broadcast", { event: "action" }, (payload) => {
        const msg = payload?.payload;
        if (!msg || !msg.type) return;

        if (msg.type === "FINI") {
          if (!isHost) return;
          const pname = (msg.playerName || "").trim();
          if (!pname) return;

          const j = findPlayerByName(pname);
          if (!j) {
            setEventZone("FINI re√ßu", "Nom introuvable: " + pname);
            return;
          }
          handlePlayerFinish(j.id, true);
          schedulePush("player_finish");
        }
      });

      // Receive state updates from DB
      rtChannel.on(
        "postgres_changes",
        { event: "UPDATE", schema: "public", table: "rooms", filter: "id=eq." + roomIdToSub },
        (payload) => {
          const newRow = payload?.new;
          if (!newRow || !newRow.state) return;

          // Host ignore its own DB echo
          if (isHost) return;

          applyPayload(newRow.state);
          setRoomStatus("Room : " + codeToSub + " (synchro OK)");
        }
      );

      rtChannel.subscribe((status) => {
        if (status === "SUBSCRIBED") {
          setConnPill("realtime");
        }
      });
    }

    async function sendAction(msg) {
      if (!rtChannel) return;
      try {
        await rtChannel.send({
          type: "broadcast",
          event: "action",
          payload: msg
        });
      } catch (e) {
        console.warn("broadcast send error:", e);
      }
    }

    function findPlayerByName(name) {
      const target = (name || "").trim().toLowerCase();
      if (!target) return null;
      return state.joueurs.find(j => (j.nom || "").trim().toLowerCase() === target) || null;
    }

    function hydratePlayerSelectionFromState() {
      if (isHost) return;

      // Try to select player by stored name
      const storedName = (document.getElementById("player-name")?.value || localStorage.getItem(LS_PLAYER_NAME) || "").trim();
      if (!storedName) return;

      const direct = findPlayerByName(storedName);
      if (direct) {
        selectedPlayerId = direct.id;
        selectedPlayerName = direct.nom;
        updatePlayerControlsEnabled();
        return;
      }

      // Populate picker
      const pickBox = document.getElementById("player-pick-box");
      const pick = document.getElementById("player-pick");
      if (!pickBox || !pick) return;

      pick.innerHTML = "";
      state.joueurs.forEach(j => {
        const opt = document.createElement("option");
        opt.value = j.id;
        opt.textContent = j.nom;
        pick.appendChild(opt);
      });
      pickBox.style.display = "block";
    }

    function resolveSelectedPlayer() {
      if (isHost) return;

      const inputName = (document.getElementById("player-name")?.value || "").trim();
      const direct = findPlayerByName(inputName);
      if (direct) {
        selectedPlayerId = direct.id;
        selectedPlayerName = direct.nom;
        localStorage.setItem(LS_PLAYER_NAME, direct.nom);
        return;
      }

      const pick = document.getElementById("player-pick");
      if (pick && pick.value) {
        const id = parseInt(pick.value, 10);
        const j = state.joueurs.find(x => x.id === id);
        if (j) {
          selectedPlayerId = j.id;
          selectedPlayerName = j.nom;
          localStorage.setItem(LS_PLAYER_NAME, j.nom);
          return;
        }
      }

      selectedPlayerId = null;
      selectedPlayerName = null;
    }

    // ==========================
    // UTILITAIRES UI + FORMAT
    // ==========================

    function formatTimeHMS(totalSeconds) {
      if (totalSeconds < 0) totalSeconds = 0;
      const h = Math.floor(totalSeconds / 3600);
      const m = Math.floor((totalSeconds % 3600) / 60);
      const s = Math.floor(totalSeconds % 60);
      const pad = (x) => x.toString().padStart(2, "0");
      return `${pad(h)}:${pad(m)}:${pad(s)}`;
    }

    function formatDeltaSeconds(sec) {
      const sign = sec >= 0 ? "+" : "-";
      const abs = Math.abs(sec);
      const sInt = Math.floor(abs);
      const centi = Math.round((abs - sInt) * 100);
      return `${sign}${sInt}"${centi.toString().padStart(2, "0")}`;
    }

    function shuffleArray(arr) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function computeOccurrences(dureeMinutes, difficulte) {
      const H = dureeMinutes / 60;
      let sprints, cotes, echappees, incidents;

      if (difficulte === "Ville") {
        sprints    = 1 * H;
        cotes      = Math.max(1, Math.round(0.5 * H));
        echappees  = Math.round(1.5 * H);
        incidents  = 2 * H;
      } else if (difficulte === "Plaine") {
        sprints    = 2 * H;
        cotes      = 1 * H;
        echappees  = 3 * H;
        incidents  = 4 * H;
      } else if (difficulte === "Montagne") {
        sprints    = 3 * H;
        cotes      = 2 * H;
        echappees  = 4 * H;
        incidents  = 6 * H;
      } else {
        sprints    = 2 * H;
        cotes      = 1 * H;
        echappees  = 3 * H;
        incidents  = 4 * H;
      }

      return {
        sprints:   Math.max(1, Math.round(sprints)),
        cotes:     Math.max(1, Math.round(cotes)),
        echappees: Math.max(1, Math.round(echappees)),
        incidents: Math.max(1, Math.round(incidents))
      };
    }

    function buildTimeline(dureeMinutes, occurrences) {
      const totalSeconds = dureeMinutes * 60;
      const events = [];

      for (let i = 0; i < occurrences.sprints; i++)   events.push("SPRINT");
      for (let i = 0; i < occurrences.cotes; i++)     events.push("COTE");
      for (let i = 0; i < occurrences.echappees; i++) events.push("ECHAPPEE");
      for (let i = 0; i < occurrences.incidents; i++) events.push("INCIDENT");

      if (events.length === 0) return [];

      const shuffled = shuffleArray(events);
      const N = shuffled.length;
      const slotSize = totalSeconds / N;

      const timeline = [];
      for (let i = 0; i < N; i++) {
        const base = i * slotSize;
        const t = base + Math.random() * slotSize;
        timeline.push({ timeOffset: t, type: shuffled[i], fired: false });
      }
      timeline.sort((a, b) => a.timeOffset - b.timeOffset);
      return timeline;
    }

    function describeEventType(type) {
      if (type === "SPRINT")   return "Sprint (maillot vert)";
      if (type === "COTE")     return "C√¥te (maillot √† pois)";
      if (type === "ECHAPPEE") return "√âchapp√©e (maillot blanc)";
      if (type === "INCIDENT") return "Incident de course";
      return type;
    }

    function isAnyEventActive() {
      return sprintActif || coteActive || echappeeActive || incidentActif;
    }

    // ==========================
    // DOM REFS
    // ==========================

    const elTimer = document.getElementById("timer");
    const elNextEvent = document.getElementById("next-event");
    const elPlayersCard = document.getElementById("players-card");
    const elTeamsCard = document.getElementById("teams-card");
    const elEventZone = document.getElementById("event-zone");

    const elSetupModal = document.getElementById("setup-modal");
    const elDuration = document.getElementById("tour-duration");
    const elPlayersInput = document.getElementById("players-input");
    const elSetupError = document.getElementById("setup-error");
    const elBtnStart = document.getElementById("btn-start");
    const elBtnDemo = document.getElementById("btn-demo");

    const elClassementModal = document.getElementById("classement-modal");
    const elClassementContent = document.getElementById("classement-content");
    const elBtnClassementClose = document.getElementById("btn-classement-close");
    const elBtnSettings = document.getElementById("btn-settings");

    const elTeamsEnabled = document.getElementById("teams-enabled");
    const elTeamsSetup = document.getElementById("teams-setup");
    const elTeam1Name = document.getElementById("team1-name");
    const elTeam1Tag = document.getElementById("team1-tag");
    const elTeam1Color = document.getElementById("team1-color");
    const elTeam2Name = document.getElementById("team2-name");
    const elTeam2Tag = document.getElementById("team2-tag");
    const elTeam2Color = document.getElementById("team2-color");
    const elTeamsAssignment = document.getElementById("teams-assignment");
    const elBtnRefreshTeams = document.getElementById("btn-refresh-teams");

    const elCoverScreen = document.getElementById("cover-screen");
    const elCoverStart = document.getElementById("btn-cover-start");
    const elMainContent = document.getElementById("main-content");

    const elHostControls = document.getElementById("host-controls");
    const elPlayerControls = document.getElementById("player-controls");
    const elBtnPlayerFini = document.getElementById("btn-player-fini");
    const elPlayerHint = document.getElementById("player-hint");

    const elHostSetup = document.getElementById("host-setup");
    const elPlayerSetup = document.getElementById("player-setup");
    const elPlayerLoginBox = document.getElementById("player-login-box");

    const elRoomCode = document.getElementById("room-code");
    const elBtnGenRoom = document.getElementById("btn-generate-room");
    const elBtnJoinRoom = document.getElementById("btn-join-room");
    const elPlayerName = document.getElementById("player-name");
    const elPlayerPick = document.getElementById("player-pick");

    const elSbUrl = document.getElementById("sb-url");
    const elSbKey = document.getElementById("sb-key");
    const elBtnSaveSupabase = document.getElementById("btn-save-supabase");

    const elBtnSprint = document.getElementById("btn-sprint");
    const elBtnCote = document.getElementById("btn-cote");
    const elBtnEchappee = document.getElementById("btn-echappee");
    const elBtnIncident = document.getElementById("btn-incident");

    // ==========================
    // UI HELPERS
    // ==========================

    function setEventZone(title, body) {
      const titleEl = elEventZone.querySelector(".event-title");
      const bodyEl = elEventZone.querySelector(".event-body");
      if (titleEl) titleEl.textContent = title || "";
      if (bodyEl) bodyEl.textContent = body || "";
    }

    function playSound(type) {
      let id = null;
      if (type === "SPRINT") id = "snd-sprint";
      if (type === "COTE") id = "snd-cote";
      if (type === "ECHAPPEE") id = "snd-echappee";
      if (type === "INCIDENT") id = "snd-incident";
      if (!id) return;

      const audio = document.getElementById(id);
      if (!audio) return;
      audio.currentTime = 0;
      audio.play().catch(() => {});
    }

    function updateRoleUI() {
      elHostControls.style.display = isHost ? "block" : "none";
      elPlayerControls.style.display = isHost ? "none" : "block";
      elHostSetup.style.display = isHost ? "block" : "none";
      elPlayerSetup.style.display = isHost ? "none" : "block";
      elPlayerLoginBox.style.display = isHost ? "none" : "block";

      if (!isHost) {
        // Force hide setup error for host-only
        elSetupError.textContent = "";
      }

      // Disable player list "Fini" buttons for players (they use their own button)
      renderPlayers();
      updatePlayerControlsEnabled();
    }

    function updatePlayerControlsEnabled() {
      if (isHost) return;
      const btn = elBtnPlayerFini;
      if (!btn) return;

      const j = state.joueurs.find(x => x.id === selectedPlayerId);
      const canFinish = !!j && state.pinteEnCours && !j.aFiniCettePinte && !pendingPlayerFinish && !!roomId;

      btn.disabled = !canFinish;

      const who = selectedPlayerName ? selectedPlayerName : "non s√©lectionn√©";
      const st = roomCode ? roomCode : "aucune room";
      elPlayerHint.textContent = `Player: ${who} | Room: ${st}`;
    }

    function refreshTeamsAssignmentUI() {
      const rawNames = (elPlayersInput.value || "")
        .split("\n")
        .map(s => s.trim())
        .filter(s => s.length > 0);

      if (rawNames.length === 0) {
        elTeamsAssignment.innerHTML =
          '<div style="color:var(--text-muted);">Ajoutez d\'abord des joueurs dans la liste au-dessus.</div>';
        return;
      }

      let html = '<div style="margin-top:4px;">';
      rawNames.forEach((name, idx) => {
        const idSelect = `team-assign-${idx}`;
        html += `
          <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:4px;">
            <span>${name}</span>
            <select id="${idSelect}" class="form-select" style="max-width:150px;">
              <option value="">Aucune √©quipe</option>
              <option value="1">√âquipe 1</option>
              <option value="2">√âquipe 2</option>
            </select>
          </div>
        `;
      });
      html += '</div>';
      elTeamsAssignment.innerHTML = html;
    }

    // ==========================
    // NEXT EVENT + TIMELINE
    // ==========================

    function updateNextEventLabel() {
      if (!elNextEvent) return;

      if (!state.timelineEvents || state.timelineEvents.length === 0 || !state.tourStartTimestamp) {
        elNextEvent.textContent = "Prochain √©v√©nement : aucun";
        return;
      }

      const elapsed = nowSeconds() - state.tourStartTimestamp;
      const next = state.timelineEvents.find(ev => !ev.fired && ev.timeOffset > elapsed);

      if (!next) {
        elNextEvent.textContent = "Prochain √©v√©nement : aucun (fin du Tour)";
        return;
      }

      const secondsToGo = Math.max(0, Math.round(next.timeOffset - elapsed));
      const minutes = Math.floor(secondsToGo / 60);
      const secs = secondsToGo % 60;

      const tStr = minutes > 0
        ? `${minutes} min ${secs.toString().padStart(2,"0")} s`
        : `${secs} s`;

      elNextEvent.textContent = `Prochain √©v√©nement : ${describeEventType(next.type)} dans ${tStr}`;
    }

    function checkTimelineEventsHostOnly() {
      if (!isHost) return;
      if (!state.timelineEvents || state.timelineEvents.length === 0 || !state.tourStartTimestamp) return;
      if (isAnyEventActive()) return;

      const elapsed = nowSeconds() - state.tourStartTimestamp;

      let triggered = false;

      state.timelineEvents.forEach(ev => {
        if (!ev.fired && ev.timeOffset <= elapsed) {
          ev.fired = true;
          triggered = true;

          if (ev.type === "SPRINT" && !sprintActif) {
            sprintActif = true;
            sprintLanceur = null;
            renderSprintInterface();
            playSound("SPRINT");
          } else if (ev.type === "COTE" && !coteActive) {
            coteActive = true;
            coteCible = Math.floor(20 + Math.random() * 60);
            renderCoteInterface();
            playSound("COTE");
          } else if (ev.type === "ECHAPPEE" && !echappeeActive) {
            echappeeActive = true;
            echappeeClics = [];
            renderEchappeeInterface();
            playSound("ECHAPPEE");
          } else if (ev.type === "INCIDENT" && !incidentActif) {
            incidentActif = true;
            incidentData = incidentsList[Math.floor(Math.random() * incidentsList.length)];
            renderIncidentInterface();
            playSound("INCIDENT");
          }
        }
      });

      cleanExpiredIncidents();

      if (triggered) {
        schedulePush("timeline_trigger");
      }
    }

    // ==========================
    // TIMER
    // ==========================

    function tickTimerUIOnly() {
      if (!state.tourFinTimestamp) {
        elTimer.textContent = "--:--:--";
        return;
      }
      const remaining = Math.floor(state.tourFinTimestamp - nowSeconds());
      elTimer.textContent = formatTimeHMS(remaining);
    }

    function tickTimerHost() {
      if (!isHost) return;
      if (!state.tourFinTimestamp) return;

      const remaining = Math.floor(state.tourFinTimestamp - nowSeconds());
      elTimer.textContent = formatTimeHMS(remaining);

      if (remaining <= 0) {
        clearInterval(state.timerInterval);
        elTimer.textContent = "00:00:00";
        endTour();
        schedulePush("end_tour");
        return;
      }

      updateNextEventLabel();
      checkTimelineEventsHostOnly();
    }

    function endTour() {
      setEventZone(
        "Fin du Tour",
        "Le temps est √©coul√©. Le Maillot Jaune est attribu√© au joueur avec le plus petit temps cumul√©."
      );
      const buttons = document.querySelectorAll(".btn-fini");
      buttons.forEach((b) => (b.disabled = true));
    }

    // ==========================
    // CLASSEMENTS
    // ==========================

    function ouvrirClassements() {
      if (state.joueurs.length === 0) {
        elClassementContent.innerHTML = "<p>Aucun joueur pour l'instant.</p>";
        elClassementModal.style.display = "flex";
        return;
      }

      const joueurs = [...state.joueurs];

      const jaune = [...joueurs].sort((a,b)=>a.tempsCumul√© - b.tempsCumul√©);
      const leaderJaune = jaune[0].tempsCumul√©;

      const vert = [...joueurs].sort((a,b)=>b.pointsVert - a.pointsVert);
      const pois = [...joueurs].sort((a,b)=>b.pointsPois - a.pointsPois);
      const blanc = [...joueurs].sort((a,b)=>b.pointsBlanc - a.pointsBlanc);

      let html = "";

      html += `<h3 style="margin:6px 0;">üü° Maillot Jaune</h3>`;
      html += `<ul style="list-style:none; padding-left:0; margin:0 0 8px 0;">`;
      jaune.slice(0,3).forEach((j,idx) => {
        const delta = j.tempsCumul√© - leaderJaune;
        const deltaStr = idx === 0 ? "leader" : formatDeltaSeconds(delta);
        html += `<li>${idx+1}. <b>${j.nom}</b> ‚Äì ${deltaStr}</li>`;
      });
      html += `</ul>`;

      html += `<h3 style="margin:6px 0;">üü¢ Maillot Vert</h3>`;
      html += `<ul style="list-style:none; padding-left:0; margin:0 0 8px 0;">`;
      vert.slice(0,3).forEach((j,idx) => {
        html += `<li>${idx+1}. <b>${j.nom}</b> ‚Äì ${j.pointsVert} pts</li>`;
      });
      html += `</ul>`;

      html += `<h3 style="margin:6px 0;">üî¥ Maillot √† Pois</h3>`;
      html += `<ul style="list-style:none; padding-left:0; margin:0 0 8px 0;">`;
      pois.slice(0,3).forEach((j,idx) => {
        html += `<li>${idx+1}. <b>${j.nom}</b> ‚Äì ${j.pointsPois} pts</li>`;
      });
      html += `</ul>`;

      html += `<h3 style="margin:6px 0;">‚ö™ Maillot Blanc</h3>`;
      html += `<ul style="list-style:none; padding-left:0; margin:0;">`;
      blanc.slice(0,3).forEach((j,idx) => {
        html += `<li>${idx+1}. <b>${j.nom}</b> ‚Äì ${j.pointsBlanc} pts</li>`;
      });
      html += `</ul>`;

      elClassementContent.innerHTML = html;
      elClassementModal.style.display = "flex";
    }

    // ==========================
    // RENDU JOUEURS + √âQUIPES
    // ==========================

    function renderPlayers() {
      const sorted = [...state.joueurs].sort((a, b) => a.tempsCumul√© - b.tempsCumul√©);
      elPlayersCard.innerHTML = "";

      const leader = sorted.length > 0 ? sorted[0].tempsCumul√© : 0;

      sorted.forEach((j, index) => {
        const row = document.createElement("div");
        row.className = "player-row";

        const topLine = document.createElement("div");
        topLine.className = "player-top-line";

        const left = document.createElement("div");
        left.style.display = "flex";
        left.style.alignItems = "center";

        const rank = document.createElement("div");
        rank.className = "player-rank";
        rank.textContent = (index + 1) + ".";
        left.appendChild(rank);

        const name = document.createElement("div");
        name.className = "player-name";
        name.textContent = j.nom;
        left.appendChild(name);

        if (j.equipeId && state.teams && state.teams.length > 0) {
          const team = state.teams.find(t => t.id === j.equipeId);
          if (team) {
            const teamBadge = document.createElement("span");
            teamBadge.style.marginLeft = "6px";
            teamBadge.style.padding = "2px 6px";
            teamBadge.style.borderRadius = "999px";
            teamBadge.style.fontSize = "0.7rem";
            teamBadge.style.fontWeight = "600";
            teamBadge.style.backgroundColor = team.color || "#444";
            teamBadge.style.color = "#000";
            teamBadge.style.textTransform = "uppercase";
            teamBadge.textContent = team.tag || "EQ";
            left.appendChild(teamBadge);
          }
        }

        topLine.appendChild(left);

        if (j.incidentActif && j.incidentLabel) {
          const inc = document.createElement("div");
          inc.className = "player-incidents";
          inc.textContent = "‚ö† " + j.incidentLabel;
          topLine.appendChild(inc);
        }

        row.appendChild(topLine);

        const badges = document.createElement("div");
        badges.className = "player-maillots";

        const badgeJaune = document.createElement("div");
        badgeJaune.className = "badge";
        const dotJ = document.createElement("span");
        dotJ.className = "badge-yellow-dot";
        const labelJ = document.createElement("span");
        if (j.tempsCumul√© === leader) {
          labelJ.textContent = "üü° leader";
        } else {
          const delta = j.tempsCumul√© - leader;
          labelJ.textContent = formatDeltaSeconds(delta);
        }
        badgeJaune.appendChild(dotJ);
        badgeJaune.appendChild(labelJ);
        badges.appendChild(badgeJaune);

        const badgeVert = document.createElement("div");
        badgeVert.className = "badge";
        const dotV = document.createElement("span");
        dotV.className = "badge-green-dot";
        const labelV = document.createElement("span");
        labelV.textContent = j.pointsVert + " pts";
        badgeVert.appendChild(dotV);
        badgeVert.appendChild(labelV);
        badges.appendChild(badgeVert);

        const badgePois = document.createElement("div");
        badgePois.className = "badge";
        const dotP = document.createElement("span");
        dotP.className = "badge-red-dot";
        const labelP = document.createElement("span");
        labelP.textContent = j.pointsPois + " pts";
        badgePois.appendChild(dotP);
        badgePois.appendChild(labelP);
        badges.appendChild(badgePois);

        const badgeBlanc = document.createElement("div");
        badgeBlanc.className = "badge";
        const dotB = document.createElement("span");
        dotB.className = "badge-white-dot";
        const labelB = document.createElement("span");
        labelB.textContent = j.pointsBlanc + " pts";
        badgeBlanc.appendChild(dotB);
        badgeBlanc.appendChild(labelB);
        badges.appendChild(badgeBlanc);

        row.appendChild(badges);

        // Host only: show per-player Fini buttons
        const actions = document.createElement("div");
        actions.className = "player-actions";
        const btn = document.createElement("button");
        btn.className = "btn-fini";
        btn.textContent = "Fini";

        if (!isHost) {
          btn.disabled = true;
          btn.title = "Mode Player: utilisez ¬´ J‚Äôai fini ma pinte ¬ª";
        } else {
          btn.disabled = !state.pinteEnCours || j.aFiniCettePinte;
          btn.addEventListener("click", () => {
            handlePlayerFinish(j.id, false);
            schedulePush("host_finish_click");
          });
        }

        actions.appendChild(btn);
        row.appendChild(actions);

        elPlayersCard.appendChild(row);
      });

      renderTeams();
      updatePlayerControlsEnabled();
    }

    function renderTeams() {
      if (!elTeamsCard) return;

      if (!state.teams || state.teams.length === 0) {
        elTeamsCard.style.display = "none";
        elTeamsCard.innerHTML = "";
        return;
      }

      const statsMap = new Map();
      state.teams.forEach(t => {
        statsMap.set(t.id, {
          team: t,
          totalTemps: 0,
          totalVerts: 0,
          totalPois: 0,
          totalBlancs: 0,
          nbJoueurs: 0
        });
      });

      state.joueurs.forEach(j => {
        if (!j.equipeId || !statsMap.has(j.equipeId)) return;
        const s = statsMap.get(j.equipeId);
        s.totalTemps += j.tempsCumul√©;
        s.totalVerts += j.pointsVert;
        s.totalPois += j.pointsPois;
        s.totalBlancs += j.pointsBlanc;
        s.nbJoueurs += 1;
      });

      let stats = Array.from(statsMap.values()).filter(s => s.nbJoueurs > 0);
      if (stats.length === 0) {
        elTeamsCard.style.display = "none";
        elTeamsCard.innerHTML = "";
        return;
      }

      stats.forEach(s => { s.avgTemps = s.totalTemps / s.nbJoueurs; });
      stats.sort((a, b) => a.avgTemps - b.avgTemps);

      const bestAvg = stats[0].avgTemps;

      let html = "";
      stats.forEach((s, idx) => {
        const delta = s.avgTemps - bestAvg;
        const deltaStr = idx === 0 ? "leader" : formatDeltaSeconds(delta);

        html += `
          <div class="player-row">
            <div class="player-top-line">
              <div style="display:flex; align-items:center;">
                <div class="player-rank">${idx + 1}.</div>
                <div class="player-name">
                  <span style="
                    display:inline-flex;
                    align-items:center;
                    padding:2px 8px;
                    border-radius:999px;
                    font-size:0.75rem;
                    font-weight:700;
                    margin-right:6px;
                    background:${s.team.color || "#444"};
                    color:#000;
                    text-transform:uppercase;
                  ">${s.team.tag || "EQ"}</span>
                  ${s.team.name || "√âquipe"}
                </div>
              </div>
              <div style="font-size:0.8rem; color:var(--text-muted);">${deltaStr}</div>
            </div>

            <div class="player-maillots">
              <div class="badge"><span class="badge-green-dot"></span><span>${s.totalVerts} pts</span></div>
              <div class="badge"><span class="badge-red-dot"></span><span>${s.totalPois} pts</span></div>
              <div class="badge"><span class="badge-white-dot"></span><span>${s.totalBlancs} pts</span></div>
            </div>
          </div>
        `;
      });

      elTeamsCard.innerHTML = html;
      elTeamsCard.style.display = "block";
    }

    // ==========================
    // FIN DE PINTE (MAILLOT JAUNE)
    // ==========================

    function handlePlayerFinish(joueurId, fromPlayerBroadcast) {
      if (!isHost) return;
      if (!state.pinteEnCours) return;

      const joueur = state.joueurs.find((j) => j.id === joueurId);
      if (!joueur) return;
      if (joueur.aFiniCettePinte) return;

      const t = nowSeconds();
      joueur.aFiniCettePinte = true;
      state.finPinteOrdre.push({ joueurId, timestamp: t });

      setEventZone(
        "Arriv√©e enregistr√©e",
        `${joueur.nom} a termin√© sa pinte. Quand tout le monde a fini, le classement de l‚Äô√©tape sera calcul√©.`
      );

      const allFinished = state.joueurs.every((j) => j.aFiniCettePinte);
      if (allFinished) {
        finalizeStage();
      } else {
        renderPlayers();
      }
    }

    function finalizeStage() {
      if (state.finPinteOrdre.length === 0) return;

      const classement = [...state.finPinteOrdre].sort((a, b) => a.timestamp - b.timestamp);
      const t0 = classement[0].timestamp;

      const bonus = [5, 2, 1];
      let resumeEtape = "R√©sultat de l‚Äô√©tape :\n";

      classement.forEach((entry, idx) => {
        const joueur = state.joueurs.find((j) => j.id === entry.joueurId);
        if (!joueur) return;

        const brut = entry.timestamp - t0;
        const b = idx < bonus.length ? bonus[idx] : 0;
        let net = brut - b;
        if (net < 0) net = 0;

        joueur.tempsCumul√© += net;

        const rang = idx + 1;
        const deltaStr = formatDeltaSeconds(brut);
        const netStr = formatDeltaSeconds(net);

        resumeEtape += `${rang}. ${joueur.nom} (${deltaStr}, bonif -${b}", net ${netStr})\n`;
      });

      state.pinteEnCours = true;
      state.finPinteOrdre = [];
      state.joueurs.forEach((j) => { j.aFiniCettePinte = false; });

      state.numeroPinte += 1;
      cleanExpiredIncidents();

      renderPlayers();
      setEventZone("√âtape termin√©e", resumeEtape.trim());

      schedulePush("finalize_stage");
    }

    // ==========================
    // INCIDENTS EXPIRATION
    // ==========================

    function cleanExpiredIncidents() {
      const now = nowSeconds();
      state.joueurs.forEach(j => {
        if (j.incidentExpirePinte !== null && j.incidentExpirePinte !== undefined) {
          if (j.incidentExpirePinte < state.numeroPinte) {
            j.incidentActif = false;
            j.incidentLabel = null;
            j.incidentExpirePinte = null;
          }
        }
        if (j.incidentExpireTimestamp !== null && j.incidentExpireTimestamp !== undefined) {
          if (now >= j.incidentExpireTimestamp) {
            j.incidentActif = false;
            j.incidentLabel = null;
            j.incidentExpireTimestamp = null;
          }
        }
      });
    }

    // ==========================
    // EVENTS UI (SPRINT/COTE/ECHAPPEE/INCIDENT)
    // Host only
    // ==========================

    function renderSprintInterface() {
      if (!isHost) return;
      const html = [];

      html.push(`<div class="event-title">‚ö° SPRiNT !</div>`);
      html.push(`<div class="event-body">Classez les joueurs dans l'ordre d'arriv√©e :</div>`);
      html.push(`<div style="margin-top:10px;">`);

      state.joueurs.forEach(j => {
        html.push(`
          <div style="margin-bottom:8px;">
            <label style="font-size:0.85rem;">${j.nom}</label>
            <select id="sprint-${j.id}" class="form-select">
              ${state.joueurs.map((_,i)=>`<option value="${i+1}">${i+1}</option>`).join("")}
            </select>
          </div>
        `);
      });

      html.push(`</div>`);
      html.push(`<button id="btn-valider-sprint" class="btn-primary" style="margin-top:12px;">Valider le sprint</button>`);

      elEventZone.innerHTML = html.join("");
      document.getElementById("btn-valider-sprint").addEventListener("click", validerSprint);
    }

    function validerSprint() {
      if (!isHost) return;
      const classements = [];

      state.joueurs.forEach(j => {
        const rank = parseInt(document.getElementById(`sprint-${j.id}`).value, 10);
        classements.push({ id: j.id, rank });
      });

      classements.sort((a,b)=>a.rank-b.rank);

      const points = [10,6,4,3,2,1];
      let result = "R√©sultats du Sprint :\n\n";

      classements.forEach((entry, idx) => {
        const joueur = state.joueurs.find(j=>j.id===entry.id);
        const p = points[idx] || 1;
        joueur.pointsVert += p;
        result += `${idx+1}. ${joueur.nom} (+${p} pts)\n`;
      });

      sprintActif = false;
      sprintCooldown = nowSeconds() + 900;
      sprintLanceur = null;

      renderPlayers();
      setEventZone("Sprint termin√©", result.trim());

      schedulePush("valider_sprint");
    }

    function renderCoteInterface() {
      if (!isHost) return;
      const html = [];

      html.push(`<div class="event-title">‚õ∞Ô∏è C√¥te</div>`);
      html.push(`<div class="event-body">Grimpez et arr√™tez-vous √† ${coteCible}%. Quand tout le monde a stopp√©, appuyez sur le bouton.</div>`);
      html.push(`<button id="btn-cote-stop" class="btn-primary" style="margin-top:12px;">Tout le monde a stopp√©</button>`);

      elEventZone.innerHTML = html.join("");
      document.getElementById("btn-cote-stop").addEventListener("click", renderCoteClassement);
    }

    function renderCoteClassement() {
      if (!isHost) return;
      const html = [];

      html.push(`<div class="event-title">Classement de la C√¥te</div>`);
      html.push(`<div class="event-body">Classez les grimpeurs du plus pr√©cis au moins pr√©cis :</div>`);
      html.push(`<div style="margin-top:10px;">`);

      state.joueurs.forEach(j => {
        html.push(`
          <div style="margin-bottom:8px;">
            <label style="font-size:0.85rem;">${j.nom}</label>
            <select id="cote-${j.id}" class="form-select">
              ${state.joueurs.map((_,i)=>`<option value="${i+1}">${i+1}</option>`).join("")}
            </select>
          </div>
        `);
      });

      html.push(`</div>`);
      html.push(`<button id="btn-valider-cote" class="btn-primary" style="margin-top:12px;">Valider la C√¥te</button>`);

      elEventZone.innerHTML = html.join("");
      document.getElementById("btn-valider-cote").addEventListener("click", validerCote);
    }

    function validerCote() {
      if (!isHost) return;
      const classements = [];

      state.joueurs.forEach(j => {
        const rank = parseInt(document.getElementById(`cote-${j.id}`).value, 10);
        classements.push({ id: j.id, rank });
      });

      classements.sort((a,b)=>a.rank-b.rank);

      const points = [8, 5, 3, 2, 1, 1, 1];
      let recap = "R√©sultats de la C√¥te :\n\n";

      classements.forEach((entry, idx) => {
        const joueur = state.joueurs.find(j=>j.id===entry.id);
        const p = points[idx] || 1;
        joueur.pointsPois += p;
        recap += `${idx+1}. ${joueur.nom} (+${p} pts)\n`;
      });

      coteActive = false;
      coteCible = null;

      renderPlayers();
      setEventZone("C√¥te termin√©e", recap.trim());

      schedulePush("valider_cote");
    }

    function renderEchappeeInterface() {
      if (!isHost) return;
      const html = [];

      html.push(`<div class="event-title">üö¥ √âchapp√©e</div>`);
      html.push(`<div class="event-body">Le plus rapide gagne. Touchez votre bouton :</div>`);
      html.push(`<div style="margin-top:12px;">`);

      state.joueurs.forEach(j => {
        html.push(`
          <button id="echappee-${j.id}" class="btn-primary" style="width:100%; margin-bottom:8px; background:#ffffff; color:#000;">
            ${j.nom}
          </button>
        `);
      });

      html.push(`</div>`);
      elEventZone.innerHTML = html.join("");

      state.joueurs.forEach(j => {
        document.getElementById(`echappee-${j.id}`).addEventListener("click", () => {
          handleEchappeeClick(j.id);
        });
      });
    }

    function handleEchappeeClick(joueurId) {
      if (!isHost) return;
      if (!echappeeActive) return;

      echappeeClics.push({ id: joueurId, t: nowSeconds() });

      if (echappeeClics.length === state.joueurs.length) {
        finalizeEchappee();
      }
    }

    function finalizeEchappee() {
      if (!isHost) return;
      echappeeActive = false;

      echappeeClics.sort((a,b)=>a.t - b.t);

      const points = [3, 1];
      let recap = "R√©sultats de l'√©chapp√©e :\n\n";

      echappeeClics.forEach((entry, idx) => {
        const joueur = state.joueurs.find(j=>j.id===entry.id);
        const p = points[idx] || 0;
        joueur.pointsBlanc += p;
        recap += `${idx+1}. ${joueur.nom} (+${p} pts)\n`;
      });

      renderPlayers();
      setEventZone("√âchapp√©e termin√©e", recap.trim());

      schedulePush("finalize_echappee");
    }

    function renderIncidentInterface() {
      if (!isHost) return;
      const inc = incidentData;
      if (!inc) return;

      let target = null;
      if (inc.type === "player") {
        const idx = Math.floor(Math.random() * state.joueurs.length);
        target = state.joueurs[idx];
      }

      let body = `${inc.label}\n\n`;
      if (inc.type === "player") body += `Cible : ${target.nom}`;
      else if (inc.type === "all") body += `Tous les joueurs sont concern√©s.`;
      else body += `Impact gameplay.`;

      elEventZone.innerHTML = `
        <div class="event-title">‚ö†Ô∏è Incident</div>
        <div class="event-body">${body}</div>
        <button id="btn-incident-ok" class="btn-primary" style="margin-top:12px;">OK</button>
      `;

      document.getElementById("btn-incident-ok").addEventListener("click", () => {
        if (inc.type === "player") {
          target.incidentActif = true;
          target.incidentLabel = inc.label;

          if (inc.duration === "1-pinte") target.incidentExpirePinte = state.numeroPinte;
          if (inc.duration === "5-min") target.incidentExpireTimestamp = nowSeconds() + 300;
        }

        if (inc.type === "all") {
          state.joueurs.forEach(j => {
            j.incidentActif = true;
            j.incidentLabel = inc.label;
            if (inc.duration === "1-pinte") j.incidentExpirePinte = state.numeroPinte;
            if (inc.duration === "5-min") j.incidentExpireTimestamp = nowSeconds() + 300;
          });
        }

        renderPlayers();

        incidentActif = false;
        incidentData = null;

        setEventZone("Aucun √©v√©nement en cours", "Quand une pinte est termin√©e, appuie sur ¬´ Fini ¬ª.");
        schedulePush("apply_incident");
      });
    }

    // ==========================
    // SETUP + START TOUR (HOST)
    // ==========================

    function readDifficulteFromRadios() {
      const radios = document.querySelectorAll('input[name="profil-etape"]');
      let difficulte = "Plaine";
      radios.forEach(r => { if (r.checked) difficulte = r.value; });
      return difficulte;
    }

    function startTourHostFromModal() {
      if (!isHost) return;

      const minutes = parseInt(elDuration.value, 10);
      const rawNames = (elPlayersInput.value || "")
        .split("\n")
        .map((s) => s.trim())
        .filter((s) => s.length > 0);

      const teamsEnabled = elTeamsEnabled && elTeamsEnabled.checked;
      state.teams = [];

      if (teamsEnabled) {
        const name1  = (elTeam1Name.value || "").trim() || "√âquipe 1";
        const tag1   = ((elTeam1Tag.value || "").trim() || "EQ1").toUpperCase();
        const color1 = elTeam1Color.value || "#FFD600";

        const name2  = (elTeam2Name.value || "").trim() || "√âquipe 2";
        const tag2   = ((elTeam2Tag.value || "").trim() || "EQ2").toUpperCase();
        const color2 = elTeam2Color.value || "#00AEEF";

        state.teams = [
          { id: 1, name: name1, tag: tag1, color: color1 },
          { id: 2, name: name2, tag: tag2, color: color2 }
        ];
      }

      if (rawNames.length < 2) {
        elSetupError.textContent = "Il faut au moins 2 joueurs pour lancer le Tour.";
        return;
      }
      if (rawNames.length > 10) {
        elSetupError.textContent = "Maximum 10 joueurs.";
        return;
      }

      state.dureeMinutes = minutes;
      state.difficulte = readDifficulteFromRadios();

      // Build timeline now (host only)
      const occ = computeOccurrences(state.dureeMinutes, state.difficulte);
      state.timelineEvents = buildTimeline(state.dureeMinutes, occ);

      state.tourStartTimestamp = nowSeconds();
      state.tourFinTimestamp = nowSeconds() + minutes * 60;

      state.pinteEnCours = true;
      state.finPinteOrdre = [];
      state.numeroPinte = 1;

      state.joueurs = rawNames.map((nom, idx) => {
        let equipeId = null;
        if (teamsEnabled && state.teams.length > 0) {
          const select = document.getElementById(`team-assign-${idx}`);
          if (select && select.value) {
            const val = parseInt(select.value, 10);
            if (!isNaN(val)) equipeId = val;
          }
        }
        return {
          id: idx + 1,
          nom,
          tempsCumul√©: 0,
          pointsVert: 0,
          pointsPois: 0,
          pointsBlanc: 0,

          incidentActif: false,
          incidentLabel: null,
          incidentExpirePinte: null,
          incidentExpireTimestamp: null,

          aFiniCettePinte: false,
          equipeId: equipeId
        };
      });

      // Reset flags
      sprintActif = false;
      sprintCooldown = 0;
      sprintLanceur = null;

      coteActive = false;
      coteCible = null;

      echappeeActive = false;
      echappeeClics = [];

      incidentActif = false;
      incidentData = null;

      if (state.timerInterval) clearInterval(state.timerInterval);
      state.timerInterval = setInterval(tickTimerHost, 1000);
      tickTimerHost();

      elSetupModal.style.display = "none";
      renderPlayers();

      setEventZone(
        "Tour lanc√©",
        "La premi√®re pinte est en cours. Appuie sur ¬´ Fini ¬ª quand un joueur termine sa pinte."
      );

      schedulePush("start_tour");
    }

    // ==========================
    // PLAYER BUTTON
    // ==========================

    async function playerPressFini() {
      if (isHost) return;

      resolveSelectedPlayer();
      if (!selectedPlayerName || !roomId) {
        setEventZone("Erreur", "Player non identifi√© ou room non join.");
        return;
      }

      // local guard
      const j = state.joueurs.find(x => x.id === selectedPlayerId);
      if (!j) {
        setEventZone("Erreur", "Ton joueur n‚Äôexiste pas dans cette room.");
        return;
      }
      if (!state.pinteEnCours || j.aFiniCettePinte) return;

      pendingPlayerFinish = true;
      updatePlayerControlsEnabled();
      setEventZone("FINI envoy√©", "En attente de confirmation du Host (synchro).");

      await sendAction({ type: "FINI", playerName: selectedPlayerName, t: nowSeconds() });

      // safety timeout if host not responding
      setTimeout(() => {
        pendingPlayerFinish = false;
        updatePlayerControlsEnabled();
      }, 6000);
    }

    // ==========================
    // EVENTS LISTENERS
    // ==========================

    elBtnSettings.addEventListener("click", () => ouvrirClassements());
    elBtnClassementClose.addEventListener("click", () => { elClassementModal.style.display = "none"; });

    // Cover
    if (elCoverScreen && elCoverStart) {
      elCoverScreen.style.display = "flex";
      elCoverScreen.style.opacity = "1";

      elCoverStart.addEventListener("click", () => {
        if (elMainContent) elMainContent.style.display = "block";
        elCoverScreen.style.opacity = "0";
        setTimeout(() => { elCoverScreen.style.display = "none"; }, 400);
      });
    }

    // Teams UI
    if (elTeamsEnabled) {
      elTeamsEnabled.addEventListener("change", () => {
        if (elTeamsEnabled.checked) {
          elTeamsSetup.style.display = "block";
          refreshTeamsAssignmentUI();
        } else {
          elTeamsSetup.style.display = "none";
          elTeamsAssignment.innerHTML = "";
        }
      });
    }

    if (elBtnRefreshTeams) {
      elBtnRefreshTeams.addEventListener("click", () => {
        refreshTeamsAssignmentUI();
      });
    }

    // Demo
    elBtnDemo.addEventListener("click", () => {
      elPlayersInput.value = "Louis\nEloi\nGabriel\nLo√Øc\nMax";
      elSetupError.textContent = "";
      if (elTeamsEnabled && elTeamsEnabled.checked) refreshTeamsAssignmentUI();
    });

    // Start tour
    elBtnStart.addEventListener("click", () => startTourHostFromModal());

    // Host event buttons
    elBtnSprint.addEventListener("click", () => {
      if (!isHost) return;
      if (sprintActif) return setEventZone("Sprint impossible", "Un sprint est d√©j√† en cours.");
      const now = nowSeconds();
      if (now < sprintCooldown) {
        const remaining = Math.ceil(sprintCooldown - now);
        return setEventZone("Sprint refus√©", `Attendre ${remaining} secondes avant de relancer un sprint.`);
      }

      // limiter lanceur √† 2
      const noms = state.joueurs.map(j => j.nom).join("\n");
      const who = prompt("Qui lance le sprint ?\n\n" + noms);
      if (!who) return;

      const lanceur = state.joueurs.find(j => j.nom.toLowerCase() === who.toLowerCase());
      if (!lanceur) return setEventZone("Erreur", "Nom introuvable.");

      if (!lanceur.sprintsLances) lanceur.sprintsLances = 0;
      if (lanceur.sprintsLances >= 2) return setEventZone("Sprint refus√©", `${lanceur.nom} a d√©j√† lanc√© 2 sprints.`);

      lanceur.sprintsLances += 1;
      sprintLanceur = lanceur.id;
      sprintActif = true;

      renderSprintInterface();
      schedulePush("start_sprint_manual");
    });

    elBtnCote.addEventListener("click", () => {
      if (!isHost) return;
      if (coteActive) return setEventZone("C√¥te impossible", "Une c√¥te est d√©j√† en cours.");
      coteCible = Math.floor(20 + Math.random() * 60);
      coteActive = true;
      renderCoteInterface();
      schedulePush("start_cote_manual");
    });

    elBtnEchappee.addEventListener("click", () => {
      if (!isHost) return;
      if (echappeeActive) return setEventZone("√âchapp√©e impossible", "Une √©chapp√©e est d√©j√† en cours.");
      echappeeActive = true;
      echappeeClics = [];
      renderEchappeeInterface();
      schedulePush("start_echappee_manual");
    });

    elBtnIncident.addEventListener("click", () => {
      if (!isHost) return;
      if (incidentActif) return setEventZone("Incident en cours", "Terminez l'incident actuel avant d'en tirer un autre.");
      incidentActif = true;
      incidentData = incidentsList[Math.floor(Math.random() * incidentsList.length)];
      renderIncidentInterface();
      schedulePush("start_incident_manual");
    });

    // Player button
    elBtnPlayerFini.addEventListener("click", () => playerPressFini());

    // Role switch in modal
    document.querySelectorAll('input[name="role-mode"]').forEach(r => {
      r.addEventListener("change", () => {
        const v = document.querySelector('input[name="role-mode"]:checked')?.value || "host";
        isHost = (v === "host");
        localStorage.setItem(LS_ROLE, v);
        updateRoleUI();
      });
    });

    // Save Supabase
    elBtnSaveSupabase.addEventListener("click", () => {
      const url = (elSbUrl.value || "").trim();
      const key = (elSbKey.value || "").trim();
      if (!url || !key) {
        setConnError("Supabase: URL et Key requis.");
        return;
      }
      localStorage.setItem(LS_SB_URL, url);
      localStorage.setItem(LS_SB_KEY, key);
      setConnError("");
      setConnPill("saved");
      // re-init
      const ok = initSupabaseFromLS();
      setConnPill(ok ? "ready" : "offline");
      if (ok) setRoomStatus("Room : pr√™t (Supabase OK)");
    });

    // Generate room
    elBtnGenRoom.addEventListener("click", async () => {
      setConnError("");
      if (!supa && !initSupabaseFromLS()) {
        setConnError("Supabase non configur√©. Ouvre Param√®tres Supabase et colle URL + ANON KEY.");
        return;
      }

      const code = genCode(5);
      elRoomCode.value = code;
      localStorage.setItem(LS_ROOM_CODE, code);

      try {
        // host creates room (or gets existing if collision)
        isHost = true;
        document.querySelector('input[name="role-mode"][value="host"]').checked = true;
        updateRoleUI();

        const row = await createOrGetRoom(code);
        roomId = row.id;
        roomCode = row.code;

        applyPayload(row.state);

        subscribeRealtime(roomId, roomCode);
        setRoomStatus("Room : " + roomCode + " (Host)");
        setConnPill("ready");

        // Push initial state once
        await pushStateNow("room_init");
      } catch (e) {
        setConnError(e.message || String(e));
      }
    });

    // Join room
    elBtnJoinRoom.addEventListener("click", async () => {
      setConnError("");
      if (!supa && !initSupabaseFromLS()) {
        setConnError("Supabase non configur√©. Ouvre Param√®tres Supabase et colle URL + ANON KEY.");
        return;
      }

      const code = safeUpper(elRoomCode.value);
      if (!code) {
        setConnError("Room code requis.");
        return;
      }
      localStorage.setItem(LS_ROOM_CODE, code);

      try {
        const row = await joinRoom(code);
        roomId = row.id;
        roomCode = row.code;

        // If role is player, load state and subscribe
        const v = document.querySelector('input[name="role-mode"]:checked')?.value || "host";
        isHost = (v === "host");
        updateRoleUI();

        applyPayload(row.state);

        subscribeRealtime(roomId, roomCode);

        setRoomStatus("Room : " + roomCode + (isHost ? " (Host)" : " (Player)"));
        setConnPill("ready");

        // If player, resolve selection now
        if (!isHost) {
          resolveSelectedPlayer();
          hydratePlayerSelectionFromState();
          updatePlayerControlsEnabled();
        } else {
          // Host joining existing room: stay authoritative, push once to assert state
          await pushStateNow("host_join_existing");
        }
      } catch (e) {
        setConnError(e.message || String(e));
      }
    });

    // Player name changes
    if (elPlayerName) {
      elPlayerName.addEventListener("input", () => {
        localStorage.setItem(LS_PLAYER_NAME, (elPlayerName.value || "").trim());
        resolveSelectedPlayer();
        updatePlayerControlsEnabled();
      });
    }
    if (elPlayerPick) {
      elPlayerPick.addEventListener("change", () => {
        resolveSelectedPlayer();
        updatePlayerControlsEnabled();
      });
    }

    // ==========================
    // BOOTSTRAP
    // ==========================

    function bootstrap() {
      // Load supabase cfg into fields
      const cfg = readSupabaseConfigFromLS();
      elSbUrl.value = cfg.url;
      elSbKey.value = cfg.key;

      const ok = initSupabaseFromLS();
      setConnPill(ok ? "ready" : "offline");

      const savedRoom = localStorage.getItem(LS_ROOM_CODE) || "";
      if (savedRoom) elRoomCode.value = savedRoom;

      const savedRole = localStorage.getItem(LS_ROLE) || "host";
      isHost = (savedRole === "host");
      const r = document.querySelector('input[name="role-mode"][value="' + savedRole + '"]');
      if (r) r.checked = true;

      const savedPlayerName = localStorage.getItem(LS_PLAYER_NAME) || "";
      if (elPlayerName) elPlayerName.value = savedPlayerName;

      updateRoleUI();

      // initial render
      renderPlayers();
      tickTimerUIOnly();
      updateNextEventLabel();
      setRoomStatus("Room : hors-ligne");
    }

    bootstrap();
  </script>
</body>
</html>
